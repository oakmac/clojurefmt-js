# Simple namespace

--Input
(ns aaa)
--Input

--Expected
(ns aaa)
--Expected

# Simple namespace 2

--Input

(
  ns aaa
)
--Input

--Expected
(ns aaa)
--Expected

# how to ns: use keywords, not symbols

--Input
(ns com.example.my-application
  (refer-clojure :exclude [get])
  (require
   [clojure.string :as string])
  (import
   (java.util Date)))

(require
  foo
  bar)
--Input

--Expected
(ns com.example.my-application
  (:refer-clojure :exclude [get])
  (:require
    [clojure.string :as string])
  (:import
    (java.util Date)))

(require
  foo
  bar)
--Expected

# how to ns: use vectors, not lists

--Input
(ns com.example.application
  [:require
   [clojure.string :as string]]
  [:import
   (java.util Date)])

[:require
  foo
  bar]
--Input

--Expected
(ns com.example.application
  (:require
    [clojure.string :as string])
  (:import
    (java.util Date)))

[:require
 foo
 bar]
--Expected

# how to ns: use vectors for require

--Input
(ns com.example.application
  (:require
   (clojure.string :as string))
  [:import
   (java.util Date)])
--Input

--Expected
(ns com.example.application
  (:require
    [clojure.string :as string])
  (:import
    (java.util Date)))
--Expected

# how to ns: use parenthesis for import

--Input
(ns com.example.application
[:import
 [java.util Date UUID]
 [java.io File]])
--Input

--Expected
(ns com.example.application
  (:import
    (java.io File)
    (java.util Date UUID)))
--Expected

# how to ns: alphabetically sort requires

--Input
;; something before

(ns foo
  (:require b [c])
  (:require a))

(something :after)
--Input

--Expected
;; something before

(ns foo
  (:require
    [a]
    [b]
    [c]))

(something :after)
--Expected

# how to ns: sort imports

--Input
(ns com.example.my-app

  (:import java.io.File
           (xxx.yyy.zzz Alpha Beta)
           hhh.eee.Ccc
           hhh.eee.Bbb
           (java.util Date UUID))
  (:require com.example.my-app.bbb com.example.my-app.ccc com.example.my-app.aaa)
  )
--Input

--Expected
(ns com.example.my-app
  (:require
    [com.example.my-app.aaa]
    [com.example.my-app.bbb]
    [com.example.my-app.ccc])
  (:import
    (hhh.eee Bbb Ccc)
    (java.io File)
    (java.util Date UUID)
    (xxx.yyy.zzz Alpha Beta)))
--Expected

# how to ns: sort refer-clojure, require, import

--Input
(ns foo
  (:require b c a)
  (:import (java.util Date))
  (:refer-clojure :exclude [get ->])
  )
--Input

--Expected
(ns foo
  (:refer-clojure :exclude [-> get])
  (:require
    [a]
    [b]
    [c])
  (:import
    (java.util Date)))
--Expected

# sort refer-clojure :only symbols

--Input
(ns foo
  (:require bbb aaa)
  (:refer-clojure :only [get -> number? == *])
  )
--Input

--Expected
(ns foo
  (:refer-clojure :only [* -> == get number?])
  (:require
    [aaa]
    [bbb]))
--Expected

# sort refer-clojure :rename symbols

--Input
(ns foo
  (:require bbb.ccc bbb, aaa)
    (:import (java.util UUID Date))
  (:refer-clojure :rename {print core-print get g,  number? is-number
                           ->> thread-last, -> thread-first}
  )
  )
--Input

--Expected
(ns foo
  (:refer-clojure :rename {-> thread-first, ->> thread-last, get g, number? is-number, print core-print})
  (:require
    [aaa]
    [bbb]
    [bbb.ccc])
  (:import
    (java.util Date UUID)))
--Expected

# how to ns: require, as, refer

--Input
(ns com.example.my-app
  (:require
    [com.example.duck :as duck :refer [quack quacking eat sleep]]
    aaa.bbb
    [com.example.cow :refer [moo eat-grass] :as cow]))
--Input

--Expected
(ns com.example.my-app
  (:require
    [aaa.bbb]
    [com.example.cow :as cow :refer [eat-grass moo]]
    [com.example.duck :as duck :refer [eat quack quacking sleep]]))
--Expected
